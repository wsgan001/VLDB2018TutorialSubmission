\section{A systematic survey of model and language options and variations}

\noindent \textbf{Step 1: Extending the relational model and SQL for graphs} As discussed above, part of the confusion is derived from the lack of compatibility with the well-known, baseline SQL, which both researchers and practitioners generally understand.

Towards a uniform explanation of the large space of current and past works, this tutorial reduces them to (minimally extended) SQL.
We start by recalling the insight that SQL tables can be viewed as graphs whose
vertices are tuples and whose edges are key-foreign key pairs. In this analogy, multi-way SQL join queries correspond to multi-hop path navigation.
We then introduce introduce a series of minimal extensions that enhance the expressiveness of SQL towards reaching that of graph query languages.

One extension introduces controlled amounts of recursion via {\em path expressions} that specify reachability constraints in the graph.
We track the concept's evolution from early systems like OQL~\cite{oql},
Lorel~\cite{lorel}, WebQL~\cite{webql}, StruQL~\cite{struql} via the standard XPath/XQuery~\cite{XQuery}
and the de facto standard Regular Path Queries (RPQs)~\cite{crpqs}, all the way to
contemporary languages such as Cypher~\cite{cypher} and Gremlin~\cite{gremlin}.
Path expressions may start with a variable, and multiple path expressions may appear in the \texttt{FROM} clause, potentially
correlated with previously defined variables of the same \texttt{FROM} clause. This feature is ruled out by SQL-92 but it has been prominently present
since OQL.

Additional extensions collaborate towards ensuring language compositionality, by enabling queries to output graphs.
For instance, they require the ability to invent fresh values to model the identities of newly constructed nodes and edges. This primitive has
its roots in object-oriented languages and its various incarnations can be invoked by the programmer either explicitly or implicitly.
We additionally require simultaneous construction of multiple linked tuples via each application of the \texttt{SELECT} clause.
Moreover, we require full compositionality, in the sense that subqueries can appear anywhere, potentially creating nested results when they appear in the \texttt{SELECT} clause.

Query languages for unrestricted graphs {\em annotated with scalar data} are compared via reduction to this extended SQL.
\arem{we need to make a high-level decision. SQL++ as is covers all the SQL/JSON dbs, but not the other graph databases. So we either formulate extensions to SQL++ (what shall we call
  the resulting language?), or we define another, more general language and mention SQL++ as sublanguage that is already in circulation.}



We next shift attention to a highly important class of graphs: they are tree-shaped and annotated with non-1NF data.
This class is motivated by the plethora of JSON databases in circulation today (as well as their XML precursors).
The corresponding plethora of query languages is classified via reduction to a modern SQL-based language, \emph{Configurable SQL++}~\cite{sqlpp-extended-corr-2015}.
Neglecting temporarily the ``configurable" aspect (discussed in Step~2), one may think of SQL++ as a semi-structured query language that is
{\em backwards compatible} with the ``textbook" SQL-92.
%and mostly backwards compatible with other relevant features of the SQL standard.
%(The cases where it is not, such as differences in type coercion, lend themselves to interesting discussed comparisons.) Hence SQL++ can be easily understood by SQL programmers and researchers.

\arem{we should shorten this}
The enabler of the relatively easy extension from SQL to genuine JSON database capability is that the semi-structured SQL++ data model is a superset of both JSON and the SQL data model. One should think of JSON objects as tuples. Then the SQL++ model can be thought of as expanding JSON with bags (as opposed to having JSON arrays only) and enriched values, i.e., atomic values that are not only numbers and strings (vendors have already made this extension).
Vice versa, one may think of SQL++ as expanding SQL with JSON features: arrays, heterogeneity, and the possibility that any value may be an arbitrary composition of the array, bag and tuple constructors, hence enabling arbitrary nested structures, such as arrays of arrays. Consequently, the SQL++ query language inputs and outputs SQL++ data. Notice that there was no such straightforward correspondence between the XML model and relational, primarily due to the lack of explicit tuples in XML.

Then we incorprorate into SQL++ salient features of past full-fledged \textit{declarative} query languages for non-relational data models: SQL non-1NF features (starting with SQL 2003), OQL,
% \cite{oql-dbpl-1989}, 
the nested relational model and query languages,
% \cite{nest-unnest-pods-1982,nested-relational-vldb-1988,nested-relational-workshop-lncs-1989} 
and XQuery (and other XML-based query languages).
% \cite{xquery-3.0-w3c-2013,xml-ql-computer-networks-1999,xml-query-language-survey-sigmod-record-2000}. 
For example, in the spirit of XQuery, JSONiq and OQL, SQL++ is a fully composable and semi-structured language, hence being able to input and output nested and heterogeneous structures. In this tutorial, a new student/researcher of semistructured data, who missed the OQL and XQuery eras, will be able to absorb the essential teachings of XQuery while they are succinctly cast as a {\em minimally modified SQL}. We describe these modifications next, which will enable an audience member with SQL background to comprehend the fundamentals of the extension to genuine JSON databases with minimal effort.

\noindent {\em Minimal semantics changes}  Instead of inventing (or re-inventing) multiple syntactic/semantic features for the same fundamental functions (something that, as we show, occassionally happens in SQL/JSON databases), the extension from SQL to SQL++ is most often achieved simply by {\em removing} semantic restrictions of SQL. Here are a few examples:
\begin{compact_enum}
\item Unlike SQL's \texttt{FROM} clause variables, which bind to tuples only, the FROM clause variables of SQL++ bind to any JSON element.
\item SQL++ is fully composable in the sense that subqueries can appear anywhere, potentially creating nested results when they appear in the \texttt{SELECT} clause.
\item While correlation of the subqueries in a \texttt{FROM} clause is not allowed in SQL-92, the SQL++ subqueries of a \texttt{FROM} clause may be freely correlated with (earlier defined) variables of the same \texttt{FROM} clause.
\item The groups created by the \texttt{GROUP BY} are directly usable in nested queries - as opposed to SQL's approach where they may only participate in aggregate functions in very limited and particular ways. Interestingly, the SQL++ approach ends up explaining in a simple, formal way even SQL's grouping and aggregation.
\item Unlike SQL, the SQL++ semantics do not require schema or any homogeneity on the input data. 
\end{compact_enum}

A complete specification of SQL++ can be found in \cite{sqlpp-survey-2015}.
Notice that features~2 to~4 above are also present in SQL 2003, which includes many 1NF features. In the interest of unifying genuine JSON databases with non-1NF features of SQL, this tutorial explains such features using SQL++, which leads to syntax and semantics succinct and significantly shorter than the SQL 2003 specification. A key methodology that leads to short, succinct semantics is the staging, which reminds of XQuery's specification: First we define an {\em SQL++ core}. Consequently, additional features and SQL compatibility is achieved as syntactic sugar over the core. 

Besides restriction removals, some extensions are also presented. For example, pivoting the tuples' attribute/value pairs to columns is a feature of some databases. Therefore, SQL++ can allow a pair of variables of the \texttt{FROM} clause to range over the attribute name and attribute value pairs of input tuples. Similarly, when a \texttt{FROM} clause ranges over an array, SQL++ allows a pair of variables to capture the data at an array position and the index of this position. In this way SQL++ seamlessly expands the logic of SQL to ``schema'' inspection and arrays.

SQL++ shows positive early adoption signs: Couchbase and UCI's AsterixDB have  adopted SQL++.%
\footnote{Author Papakonstantinou has collaborated with the AsterixDB and Couchbase teams on specifying SQL++.}
An earlier version of SQL++ has been used by the federated query processor of the UCSD FORWARD application development platform \texttt{http://forward.ucsd.edu/sqlpp}.

After having taught Step 1, we will show that multiple model and language differences are superficial syntactic differences.

\noindent \textbf{Step 2: Substantial Semantic Differences between Databases} However, not all differences are superficial. Furthermore, this tutorial does not suggest that SQL++ (or some close descendant thereof) will become a standard and remove the many variations that are now found in this space. If nothing else, the gap between genuine JSON databases and SQL/JSON is relatively deep as SQL/JSON is very much based on tables and semantics around tables. Furthermore, via communication with genuine JSON database vendors we recognize that a model and query language standard is premature for such a young and fast-evolving area. Yet, the language designers and researchers need to know now the design options that are available to them and the options that have been used by others, especially as it pertains to the handling of semi-structured aspects (semantics for missing attributes, heterogeneous types, etc), which are not captured by the SQL backwards compatibility. 
Towards this goal the tutorial utilizes an extension of SQL++ into Configurable SQL++, which is essentially a guery language generator. Depending on the options that are chosen for various features, different capabilities are assumed and different semantics emerge.

The Configurable SQL++ explains the multiple options that language designers have and the options they have chosen in current systems. The Configurable SQL++ includes {\em configuration options} that describe 
\begin{compact_enum}
\item which features are supported and 
\item (for the supported features) different options of language semantics that formally capture the variations of existing database query languages. 
\end{compact_enum}

One particular example where configuration options capture differences concisely, is the behavior of paths of the various query languages in the absence of information. For example, consider a JSON object \gt{\{a:1, b:2\}} and a path that navigates into the absent path \gt{c}. Languages differ on what is the result of \gt{c}. Is it an error? Is it a special value? If it is a special value, how does it behave in other features of the query language? Is the query writer given control on what special value may emerge or whether an error will be thrown? A configuration option captures these differences precisely. 

By appropriate choices of configuration options, the Configurable SQL++ semantics morphs into the semantics of other query languages. Hence, the audience will be able to understand the essential differences between the various query languages, without being swamped by their superficial syntactic differences. Given the time constraints, the comparisons will be mostly around the SQL standard, three well known databases (Cassandra CQL, MongoDB, Couchbase N1QL) and one academia-originating system (AsterixDB AQL). Selected features will be explained as particular settings of various configuration options. The reader can find the ``configuration options" surveying approach, as well as coverage of additional databases, in the companion documents of this tutorial at \textbf{http://db.ucsd.edu/TutorialSIGMOD16/}.  

We expect that some of the results listed in the feature matrices describing configuration options will change in the next years as the space evolves rapidly.
Despite the forthcoming changes, we expect Configurable SQL++ to remain a standing tool in understanding the space, since by understanding each database's capabilities in terms of applicable options, the reader can focus on the fundamental differences of the databases. To further facilitate understanding of Configurable SQL++ and the effect of the various configuration options, we provide a web-accessible reference implementation of Configurable SQL++ at \texttt{http://forward.ucsd.edu/sqlpp}.

Finally, with respect to configurability, we note the potential applicability of the formal capture (by the Configurable SQL++) of capability and semantic differences in the area of polystore querying and query rewriting \cite{DugganESBHKMMMZ15}.

\noindent \textbf{Step 3: Additional Features} We will also discuss features, many of which coming from XQuery, that have not been captured by configuration options and are not present in current industrial languages.  These will prompt a more open-ended discussion of language designs and trade-offs. A notable one is type coercion - the approaches and the pros and cons.

\noindent \textbf{Step 4: Languages with Operational Semantics Tied to the Computation Model}
Recently we have witnessed a trend towards development of high-level graph query languages that are deliberately not purely declarative, instead featuring an operational semantics tied to the
underlying computation model, which is typically a Bulk Synchronous Parallel (BSP) instance presented as a variation of the  Map-Reduce programming paradigm.
Prominent examples are Gremlin and GSQL. We discuss this class of queries.

\noindent \textbf{Step 5: Lack of Typing}
We also discuss the impact of the lack of typing on the expressvity of graph query languages.


\noindent \textbf{Open Issues} Finally, we emphasize open issues in the expansion from structured to semistructured querying and briefly discuss interoperability challenges induced by language differences.

